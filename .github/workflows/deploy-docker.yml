name: Deploy to Production

on:
  workflow_run:
    workflows: ["Test and Lint"]
    types:
      - completed
    branches: [ "main" ]
  workflow_dispatch: {} # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Only runs after test workflow completes successfully (or manual dispatch)
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # When triggered by workflow_run, checkout the commit from that workflow
          ref: ${{ github.event.workflow_run.head_sha || github.ref }}
          fetch-depth: 0

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: |
            ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add host to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.HOST }} >> ~/.ssh/known_hosts

      - name: Sync repository to server
        run: |
          rsync -az --delete --exclude '.git' --exclude 'cache' ./ ${{ secrets.USER }}@${{ secrets.HOST }}:~/aviationwx/

      - name: Ensure cache directories exist
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
          set -euo pipefail
          cd ~/aviationwx
          # Create cache directories with permissions for www-data container user (UID 33)
          sudo mkdir -p cache/webcams
          # Use 777 for cache directory (acceptable for cache, no sensitive data)
          # Or alternatively: sudo chown -R 33:33 cache (www-data user)
          sudo chmod -R 777 cache
          # Ensure parent cache directory also has correct permissions
          sudo chmod 777 cache || true
          # Ensure host log directory exists for bind-mount and rotation
          sudo mkdir -p /var/log/aviationwx
          sudo chown root:root /var/log/aviationwx
          sudo chmod 755 /var/log/aviationwx
          EOF

      - name: Ensure SSL certificates are in place
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
          set -euo pipefail
          cd ~/aviationwx
          # Verify we're running as the correct user
          CURRENT_USER=$(whoami)
          echo "Running as user: $CURRENT_USER"
          
          # Create SSL directory if it doesn't exist
          mkdir -p ssl
          
          # Copy SSL certificates from Let's Encrypt if they exist
          # This ensures certificates are available for Nginx container
          # All operations run as aviationwx user, using sudo for protected operations
          # Use sudo test to check if files exist (directory permissions are root-only)
          if sudo test -f /etc/letsencrypt/live/aviationwx.org/fullchain.pem && sudo test -f /etc/letsencrypt/live/aviationwx.org/privkey.pem; then
            echo "Copying SSL certificates from Let's Encrypt..."
            # Copy certificates (requires sudo to read from /etc/letsencrypt/)
            if sudo cp /etc/letsencrypt/live/aviationwx.org/fullchain.pem ssl/; then
              if sudo cp /etc/letsencrypt/live/aviationwx.org/privkey.pem ssl/; then
                # Set correct ownership and permissions
                sudo chown -R $CURRENT_USER:$CURRENT_USER ssl/
                sudo chmod 644 ssl/fullchain.pem
                sudo chmod 600 ssl/privkey.pem
                echo "✓ SSL certificates copied successfully"
              else
                echo "⚠️  Failed to copy privkey.pem"
                exit 1
              fi
            else
              echo "⚠️  Failed to copy fullchain.pem"
              exit 1
            fi
          elif [ -f ssl/fullchain.pem ] && [ -f ssl/privkey.pem ]; then
            echo "✓ SSL certificates already exist in ~/aviationwx/ssl/"
            # Verify permissions are correct
            sudo chown -R $CURRENT_USER:$CURRENT_USER ssl/ || true
            sudo chmod 644 ssl/fullchain.pem || true
            sudo chmod 600 ssl/privkey.pem || true
          else
            echo "⚠️  SSL certificates not found in /etc/letsencrypt/live/aviationwx.org/ or ~/aviationwx/ssl/"
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "SSL CERTIFICATES MISSING"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            echo "Nginx container will fail to start without SSL certificates."
            echo "You need to generate certificates with Certbot first."
            echo ""
            
            # Check if Certbot is installed
            if command -v certbot >/dev/null 2>&1; then
              echo "✓ Certbot is installed"
              echo ""
              echo "To generate wildcard certificates (DNS-01 challenge):"
              echo ""
              echo "  1. Install Cloudflare DNS plugin:"
              echo "     sudo apt install certbot python3-certbot-dns-cloudflare -y"
              echo ""
              echo "  2. Create Cloudflare API token (scoped to zone):"
              echo "     - Permissions: Zone → DNS → Edit; Zone → Zone → Read"
              echo "     - Resources: Include → Specific zone → aviationwx.org"
              echo ""
              echo "  3. Store token:"
              echo "     mkdir -p ~/.secrets"
              echo "     printf 'dns_cloudflare_api_token = %s\\n' 'YOUR_TOKEN' > ~/.secrets/cloudflare.ini"
              echo "     chmod 600 ~/.secrets/cloudflare.ini"
              echo ""
              echo "  4. Generate certificates:"
              echo "     sudo certbot certonly \\"
              echo "       --dns-cloudflare \\"
              echo "       --dns-cloudflare-credentials ~/.secrets/cloudflare.ini \\"
              echo "       -d aviationwx.org -d '*.aviationwx.org' \\"
              echo "       --non-interactive --agree-tos -m your@email.com"
              echo ""
              echo "  5. Copy certificates:"
              echo "     sudo cp /etc/letsencrypt/live/aviationwx.org/fullchain.pem ~/aviationwx/ssl/"
              echo "     sudo cp /etc/letsencrypt/live/aviationwx.org/privkey.pem ~/aviationwx/ssl/"
              echo "     sudo chown -R $CURRENT_USER:$CURRENT_USER ~/aviationwx/ssl"
              echo "     sudo chmod 644 ~/aviationwx/ssl/fullchain.pem"
              echo "     sudo chmod 600 ~/aviationwx/ssl/privkey.pem"
            else
              echo "⚠️  Certbot is not installed"
              echo ""
              echo "To install Certbot and generate certificates:"
              echo ""
              echo "  1. Install Certbot with Cloudflare DNS plugin:"
              echo "     sudo apt update && sudo apt install -y certbot python3-certbot-dns-cloudflare"
              echo ""
              echo "  2. Follow steps 2-5 above (create Cloudflare token, generate certs, copy them)"
            fi
            
            echo ""
            echo "After certificates are in place, redeploy to continue."
            echo ""
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo ""
            # Fail the deployment since Nginx won't start without certificates
            exit 1
          fi
          EOF

      - name: Deploy via Docker Compose
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
          set -euo pipefail
          cd ~/aviationwx
          docker compose -f docker-compose.prod.yml up -d --build
          docker system prune -f
          EOF

      - name: Ensure app log directory and file
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
          set -euo pipefail
          cd ~/aviationwx
          # Create log file on host (bind-mounted into container)
          sudo touch /var/log/aviationwx/app.log
          sudo chown root:adm /var/log/aviationwx/app.log || true
          sudo chmod 640 /var/log/aviationwx/app.log || true
          # Create logrotate rule on host for app log
          sudo tee /etc/logrotate.d/aviationwx > /dev/null <<'LR'
            /var/log/aviationwx/app.log {
                size 100M
                rotate 50
                compress
                delaycompress
                missingok
                notifempty
                copytruncate
            }
            LR
          # Force a logrotate config test (dry-run)
          if command -v logrotate >/dev/null 2>&1; then sudo logrotate -d /etc/logrotate.conf || true; fi
          EOF

      - name: Restart Nginx container to pick up config changes
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
          set -euo pipefail
          cd ~/aviationwx
          # Restart Nginx container to ensure it picks up new nginx.conf
          # This is safer than reload since config file is mounted as volume
          docker compose -f docker-compose.prod.yml restart nginx || docker compose -f docker-compose.prod.yml up -d nginx
          # Verify Nginx container is running and config is valid
          sleep 2
          if docker compose -f docker-compose.prod.yml exec -T nginx nginx -t 2>&1 | grep -q "syntax is ok\|test is successful"; then
            echo "✓ Nginx configuration is valid"
          else
            echo "⚠ Nginx config test failed, but container is running"
          fi
          EOF
      
      - name: Post-deployment health check
        run: |
          ssh ${{ secrets.USER }}@${{ secrets.HOST }} << 'EOF'
          set -euo pipefail
          cd ~/aviationwx
          
          echo "Running post-deployment health checks..."
          
          # Wait for containers to be ready (give them time to start)
          echo "Waiting for containers to start..."
          sleep 8
          
          # Check if containers are running (check both services explicitly)
          CONTAINER_STATUS=$(docker compose -f docker-compose.prod.yml ps --format json 2>/dev/null || docker compose -f docker-compose.prod.yml ps)
          
          # Count running containers (both web and nginx should be up)
          RUNNING_COUNT=$(docker compose -f docker-compose.prod.yml ps --status running --format json 2>/dev/null | grep -c '"State":"running"' || docker compose -f docker-compose.prod.yml ps | grep -c "Up" || echo "0")
          
          # Check that we have at least the web container (nginx is optional but should be running too)
          if [ "$RUNNING_COUNT" -lt "1" ]; then
            echo "❌ Containers are not running"
            echo "Container status:"
            docker compose -f docker-compose.prod.yml ps
            echo ""
            echo "Recent logs:"
            docker compose -f docker-compose.prod.yml logs --tail=30
            exit 1
          fi
          
          echo "✓ Containers are running (${RUNNING_COUNT} container(s) up)"
          
          # Wait for Apache to be fully ready
          echo "Waiting for services to be ready..."
          sleep 10
          
          # Check if web container is responding (from inside container via exec)
          # This is more reliable than checking from host since Apache might have Host header issues
          echo "Testing web container from inside..."
          if ! docker compose -f docker-compose.prod.yml exec -T web curl -f -s --max-time 5 http://localhost/ > /dev/null 2>&1; then
            echo "❌ Web container is not responding (internal check failed)"
            echo "Checking container logs..."
            docker compose -f docker-compose.prod.yml logs web | tail -50
            echo "Checking container status..."
            docker compose -f docker-compose.prod.yml ps
            exit 1
          fi
          
          echo "✓ Web container is responding (internal check passed)"
          
          # Also check from host port (this might fail if Apache has Host header restrictions)
          APP_PORT=${APP_PORT:-8080}
          echo "Testing web container from host on port ${APP_PORT}..."
          if curl -f -s --max-time 5 http://127.0.0.1:${APP_PORT}/ > /dev/null 2>&1; then
            echo "✓ Web container is also responding from host on port ${APP_PORT}"
          else
            echo "⚠️  Web container not accessible from host (but internal check passed - this may be expected)"
            echo "This is OK if Nginx reverse proxy is handling external requests"
          fi
          
          # Check if diagnostics page loads (optional check)
          if ! curl -f -s --max-time 5 http://127.0.0.1:${APP_PORT}/diagnostics.php > /dev/null 2>&1; then
            echo "⚠️  Diagnostics page not accessible (may be expected)"
          else
            echo "✓ Diagnostics page accessible"
          fi
          
          # Check if config-utils.php exists
          if ! docker compose -f docker-compose.prod.yml exec -T web test -f /var/www/html/config-utils.php; then
            echo "❌ config-utils.php not found in container"
            exit 1
          fi
          
          echo "✓ config-utils.php present"
          
          # Check if rate-limit.php exists
          if ! docker compose -f docker-compose.prod.yml exec -T web test -f /var/www/html/rate-limit.php; then
            echo "❌ rate-limit.php not found in container"
            exit 1
          fi
          
          echo "✓ rate-limit.php present"
          
          # Check APCu extension
          if ! docker compose -f docker-compose.prod.yml exec -T web php -m | grep -q apcu; then
            echo "⚠️  APCu extension not loaded (rate limiting will be disabled)"
          else
            echo "✓ APCu extension loaded"
          fi
          
          echo "✅ All health checks passed"
          
          # Test webcam endpoints (smoke test)
          echo "Testing webcam endpoints..."
          # Test JPG endpoint for sample airport (assuming kspb exists)
          if curl -f -s --max-time 10 "http://127.0.0.1:${APP_PORT}/webcam.php?id=kspb&cam=0&fmt=jpg" > /tmp/webcam_test.jpg 2>/dev/null; then
            SIZE=$(stat -f%z /tmp/webcam_test.jpg 2>/dev/null || stat -c%s /tmp/webcam_test.jpg 2>/dev/null || echo "0")
            CTYPE=$(curl -sI "http://127.0.0.1:${APP_PORT}/webcam.php?id=kspb&cam=0&fmt=jpg" 2>/dev/null | grep -i 'content-type' | cut -d' ' -f2 | tr -d '\r' || echo "")
            if [ "$SIZE" -gt "0" ] && echo "$CTYPE" | grep -qi "image/jpeg"; then
              echo "✓ Webcam JPG endpoint working (size: ${SIZE} bytes, type: ${CTYPE})"
              rm -f /tmp/webcam_test.jpg
            else
              echo "⚠️  Webcam JPG endpoint returned invalid response (size: ${SIZE}, type: ${CTYPE})"
            fi
          else
            echo "⚠️  Webcam JPG endpoint not accessible (may be expected if no webcams configured)"
          fi
          
          # Test WEBP endpoint
          if curl -f -s --max-time 10 "http://127.0.0.1:${APP_PORT}/webcam.php?id=kspb&cam=0&fmt=webp" > /tmp/webcam_test.webp 2>/dev/null; then
            SIZE=$(stat -f%z /tmp/webcam_test.webp 2>/dev/null || stat -c%s /tmp/webcam_test.webp 2>/dev/null || echo "0")
            CTYPE=$(curl -sI "http://127.0.0.1:${APP_PORT}/webcam.php?id=kspb&cam=0&fmt=webp" 2>/dev/null | grep -i 'content-type' | cut -d' ' -f2 | tr -d '\r' || echo "")
            if [ "$SIZE" -gt "0" ] && echo "$CTYPE" | grep -qi "image/webp"; then
              echo "✓ Webcam WEBP endpoint working (size: ${SIZE} bytes, type: ${CTYPE})"
              rm -f /tmp/webcam_test.webp
            else
              echo "⚠️  Webcam WEBP endpoint returned invalid response (size: ${SIZE}, type: ${CTYPE})"
            fi
          else
            echo "ℹ️  Webcam WEBP endpoint not accessible (may be expected if WEBP not generated yet)"
          fi
          
          EOF

